5. 上层应用开发接口
5.1 概述
在遥控模式下机器人通过WebSocket通信端口5000来接收用户端请求指令，例如让机器人站起、蹲下、行走等。WebSocket是一种实时通信协议，在机器人和用户端之间建立长连接，以便快速有效地传输控制信息和数据。如下图所示：
[图片]
5.2 通信协议格式
当机器人通过 WebSocket 接收客户端指令时，采用 JSON 数据协议进行信息传递。这种方式具有显著优势：WebSocket 是一种全双工通信协议，能够在客户端与服务器之间建立实时、低延迟的连接，特别适合频繁交互的应用场景。JSON 数据协议则以其简洁、可读性强的结构，确保数据传输直观明了，且具有跨平台、跨语言的兼容性。WebSocket 与 JSON 的结合不仅与编程语言无关，适用于各种设备和系统，还能提升开发的灵活性和维护的便利性。
- 请求数据格式包含以下字段：
  - accid：机器人序列号，注意修为您机器人的序列号；
  - title：指令名称，以“request_”为前缀；
  - timestamp：指令发出时间戳，单位为毫秒；
  - guid：指令的唯一标识符，用于区分不同的请求指令。如果是同步接口，则需要在“response_xxx”响应消息中通过guid字段将值带回给客户端。客户端接收到响应消息后，可以通过比较guid字段的值是否与请求指令中的值相同来判断指令是否执行完成；
  - data：存放请求指令的数据内容。可以根据具体需求包含多个子字段，以存放请求指令所需的数据内容，例如执行动作的参数、发送消息的文本内容等等；
  - 示例如下：
{
  "accid": "PF_TRON1A_075", # 机器人序列号，注意修为您机器人的序列号
  "title": "request_xxx",   # 指令名称，以“request_”为前缀
  "timestamp": 1672373633989, # 指令发出时间戳，单位为毫秒
  "guid": "746d937cd8094f6a98c9577aaf213d98", # 指令的唯一标识符，用于区分不同的请求指令
  "data": {}  # 存放请求指令的数据内容
}
- 响应数据格式包含以下字段：
  - accid：机器人序列号，注意修为您机器人的序列号；
  - title：指令名称，以“response_”为前缀；
  - timestamp：指令发出时间戳，单位为毫秒；
  - guid：与对应请求指令的guid值相同；
  - data：至少应该包含一个“result”子字段，用于存放请求指令的执行结果数据。如果有需要，还可以包含其他子字段，例如错误码、错误信息等用于描述操作结果的信息；
  - 示例如下：
{
  "accid": "PF_TRON1A_075",   # 机器人序列号，注意修为您机器人的序列号
  "title": "response_xxx",  # 指令名称，以“response_”为前缀
  "timestamp": 1672373633989, # 指令发出时间戳，单位为毫秒
  "guid": "746d937cd8094f6a98c9577aaf213d98", # 与对应请求指令的guid值相同
  "data": { # 存放响应指令的具体数据内容
    "result": "success"  # “result” 用于存放请求指令处理是否成功，它的值为：“success 或 fail_xxx”
  }
}
- 消息推送：它是机器人主动向客户端发送信息的过程。这些信息可以包括机器人的序列号、当前运行状态、执行的操作等数据。通过及时地向客户端发送这些信息，机器人可以帮助客户端更好地理解它的工作状态，从而更好地使用它提供的服务。它的数据格式包含以下字段：
  - accid：机器人序列号，注意修为您机器人的序列号；
  - title：指令名称，以“notify_”为前缀；
  - timestamp：消息发出时间戳，单位为毫秒；
  - guid：消息的guid值，唯一标识这条消息；
  - data：存放消息数据内容。可以根据具体需求包含多个子字段，以存放请求指令所需的数据内容；
  - 示例如下：
{
  "accid": "PF_TRON1A_075",   # 机器人序列号，注意修为您机器人的序列号
  "title": "notify_xxx",  # 消息名称，以“notify_”为前缀
  "timestamp": 1672373633989, # 消息发出时间戳，单位为毫秒
  "guid": "746d937cd8094f6a98c9577aaf213d98", # 消息的guid值，唯一标识这条消息
  "data": { } # 存放消息数据内容
}
5.3 查看软件序列号(ACCID)
  - 连接机器人无线网络
    - 机器人开机完成后，使用个人电脑连接机器人Wi-Fi，名称格式通常为「PF_TRON1A_xxx」
    - 输入Wi-Fi密码：12345678
  - 在浏览器中输入http://10.192.1.2:8080可以进入“机器人信息页”，并查看机器人信息。如下图所示，页面中显示的SN (序列号) 为PF_TRON1A_075，其中PF_TRON1A_075便是此机器人的软件序列号。
[图片]
5.4 通信测试方法
Postman是一个流行的API开发环境，可以用于测试WebSocket接口。使用Postman测试WebSocket接口，请按照以下步骤操作：
  - 安装postman，下载地址：https://www.postman.com/downloads/?utm_source=postman-home；
  - 打开Postman，并创建一个WebSocket的请求；
  - 连接机器人无线网络
    - 机器人开机完成后，使用个人电脑连接机器人Wi-Fi，名称格式通常为「WF_TRON1A_xxx」
    - 输入Wi-Fi密码：12345678
  - 在请求的URL中输入WebSocket接口的地址，例如，“ws://10.192.1.2:5000”;
  - 在“Message”中，输入要发送的指令请求；
  - 单击“Send”按钮，发送请求指令；
  - 发送指令后，可以从服务器接收响应消息。使用Postman的响应窗口查看服务器返回的数据，并检查是否符合预期结果。
[图片]
5.5 协议接口定义
该机器人接口设计遵循与遥控器操控一致的流程和状态流转，确保调用顺序、响应时序及状态过渡与遥控器控制逻辑严格对齐。用户通过接口调用可获得如同使用遥控器的直观体验，同时支持遥控器与接口间的无缝切换，实现统一、稳定的机器人操控效果。
暂时无法在飞书文档外展示此内容
5.5.1 蹲起状态
5.5.1.1 请求：request_stand_mode
{
  "accid": "PF_TRON1A_075",  // 机器人序列号，注意修为您机器人的序列号；
  "title": "request_stand_mode",
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {
  }
}
5.5.1.2 响应：response_stand_mode
{
  "accid": "PF_TRON1A_075",
  "title": "response_stand_mode",
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {
    "result": "success"  // success: 成功, fail_imu: IMU 错误, fail_motor: 电机错误
}
5.5.1.3 消息推送：notify_stand_mode
  机器人站起过程失败或完成后，主动推送此消息。
{
  "accid": "PF_TRON1A_075",
  "title": "notify_stand_mode",
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {
    "result": "success"  // success: 成功, fail_imu: IMU 错误, fail_motor: 电机错误
  }
}
5.5.2 行走状态
5.5.2.1 请求：request_walk_mode
{
  "accid": "PF_TRON1A_075", // 机器人序列号，注意修为您机器人的序列号；
  "title": "request_walk_mode",
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {
  }
}
5.5.2.2 响应：response_walk_mode
{
  "accid": "PF_TRON1A_075",
  "title": "response_walk_mode",
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {
    "result": "success"  // success: 成功, fail_imu: IMU 错误, fail_motor: 电机错误
}
5.5.2.3 消息推送：notify_walk_mode
  机器人站起过程失败或完成后，主动推送此消息。
{
  "accid": "PF_TRON1A_075",
  "title": "notify_walk_mode",
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {
    "result": "success"  // success: 成功, fail_imu: IMU 错误, fail_motor: 电机错误
  }
}
5.5.3 控制行走
5.5.3.1 请求：request_twist
  请按30Hz及以上发送指令。
  - 点足和掌足模式下按如下规则：
{
  "accid": "PF_TRON1A_075", // 机器人序列号，注意修为您机器人的序列号；
  "title": "request_twist",
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {
    "x": 0.0,   //  前进后退速度比值，取值范围[-1, 1]
    "y": 0.0,   //  横向行走速度比值，取值范围[-1, 1]
    "z": 0.0    //  旋转角速度比值，取值范围[-1, 1]
  }
}
  - 轮足模式下按如下规则：
{
  "accid": "WF_TRON1A_075", // 机器人序列号，注意修为您机器人的序列号；
  "title": "request_twist",
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {
    "x": 0.0,   //  前进后退速度（m/s），取值范围[-3.0, 3.0]；同时注意，楼梯模式下发速度需要大于1.5，否则上不了楼梯
    "y": 0.0,   //  横向行走速度为0.0（m/s），轮足模式下不支持横向移动
    "z": 0.0    //  旋转角速度（m/s），取值范围[-1.5, 1.5]
  }
}
5.5.3.2 响应：无
5.5.3.3 消息推送：notify_twist
  机器人行走失败时，主动推送此消息。
{
  "accid": "PF_TRON1A_075",
  "title": "notify_twist",
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {
    "result": "fail_motor"  // fail_imu: IMU 错误, fail_motor: 电机错误
  }
}
5.5.4 调整机器身高
5.5.4.1 请求：request_base_height
{
  "accid": "PF_TRON1A_075", // 机器人序列号，注意修为您机器人的序列号；
  "title": "request_base_height",
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {
    "direction": -1  // 1：表示升高，-1：表示降低
                     // 每次调用此请求会使机器人身高相应升高或降低 5cm
  }
}
5.5.4.2 响应：response_base_height
{
  "accid": "PF_TRON1A_075",
  "title": "response_base_height",
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {
    "result": "success"  // success: 成功, fail_status: 则表示机器人当前状态不允许调整身高
  }
}
5.5.4.3 消息推送：无
5.5.5 蹲下
5.5.5.1 请求：request_sitdown
{
  "accid": "PF_TRON1A_075", // 机器人序列号，注意修为您机器人的序列号；
  "title": "request_sitdown",
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {}
}
5.5.5.2 响应：response_sitdown
{
  "accid": "PF_TRON1A_075",
  "title": "response_sitdown",
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {
    "result": "success"  // success: 成功, fail_imu: IMU 错误, fail_motor: 电机错误
  }
}
5.5.5.3 消息推送：notify_sitdown
  机器人蹲下过程失败或完成后，主动推送此消息。
{
  "accid": "PF_TRON1A_075",
  "title": "notify_sitdown",
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {
    "result": "success"  // success: 成功, fail_imu: IMU 错误, fail_motor: 电机错误
  }
}
5.5.6 开启楼梯模式
5.5.6.1 请求：request_stair_mode
  本功能仅适用于 TRON1 型号的双轮足机器人。
{
  "accid": "PF_TRON1A_075", // 机器人序列号，注意修为您机器人的序列号；
  "title": "request_stair_mode",
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {
      "enable": true  // true: 开启楼梯模式, false: 关闭楼梯模式
  }
}
5.5.6.2 响应：response_stair_mode
{
  "accid": "PF_TRON1A_075",
  "title": "response_stair_mode",
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {
    "result": "success"  // success: 成功, fail_imu: IMU 错误, fail_motor: 电机错误
  }
}
5.5.6.3 消息推送：无
5.5.7 开启踏步模式
5.5.7.1 请求：request_marktime_mode
  本功能仅适用于 TRON1 型号的双足机器人。
{
  "accid": "PF_TRON1A_075", // 机器人序列号，注意修为您机器人的序列号；
  "title": "request_marktime_mode",
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {
      "enable": true  // true: 开启踏步模式, false: 关闭踏步模式
  }
}
5.5.7.2 响应：response_marktime_mode
{
  "accid": "PF_TRON1A_075",
  "title": "response_marktime_mode",
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {
    "result": "success"  // success: 成功, fail_imu: IMU 错误, fail_motor: 电机错误
  }
}
5.5.7.3 消息推送：无
5.5.8 紧急停止
5.5.8.1 请求：request_emgy_stop
{
  "accid": "PF_TRON1A_075", // 机器人序列号，注意修为您机器人的序列号；
  "title": "request_emgy_stop",
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {}
}
5.5.8.2 响应：response_emgy_stop
  
{
  "accid": "PF_TRON1A_075",
  "title": "response_emgy_stop",
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {
    "result": "success"  // success: 成功, fail_imu: IMU 错误, fail_motor: 电机错误
  }
}
5.5.8.3 消息推送：无
5.5.9 开启里程计
5.5.9.1 请求：request_enable_odom
  该功能用于开启里程计推送，开启后系统将主动推送里程计数据（注意：轮足机器人才有里程计）。
{
  "accid": "WF_TRON1A_075", // 机器人序列号，注意修为您机器人的序列号；
  "title": "request_enable_odom",
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {
      "enable": true  // true: 开启里程计, false: 禁用里程计
  }
}
5.5.9.2 响应：response_enable_imu
{
  "accid": "WF_TRON1A_075",
  "title": "response_enable_odom",
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {
    "result": "success"  // success: 成功, fail_odom: 不支持
  }
}
5.5.9.3 消息推送：notify_odom
  开启里程计后，系统将主动推送包含里程计数据的消息。
{
  "accid": "WF_TRON1A_075", 
  "title": "notify_odom", 
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {
      "pose_orientation": [0.0, 0.0, 0.0, 0.0], // 姿态 [x, y, z, w]
      "pose_position": [0.0, 0.0, 0.0],         // 位置 [x, y, z] in m
      "twist_linear": [0.0, 0.0, 0.0],          // 线速度 [x, y, z] in m/s
      "twist_angular": [0.0, 0.0, 0.0]          // 角速度 [x, y, z] in rad/s
  }
}

5.5.10 开启IMU数据
5.5.10.1 请求：request_enable_imu
  该功能用于开启IMU数据推送，开启后系统将主动推送IMU数据。
{
  "accid": "PF_TRON1A_075", // 机器人序列号，注意修为您机器人的序列号；
  "title": "request_enable_imu",
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {
      "enable": true  // true: 开启IMU, false: 禁用IMU
  }
}
5.5.10.2 响应：response_enable_imu
{
  "accid": "PF_TRON1A_075",
  "title": "response_enable_imu",
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {
    "result": "success"  // success: 成功, fail_imu: IMU
  }
}
5.5.10.3 消息推送：notify_imu
  开启IMU数据后，系统将主动推送包含IMU状态的消息。
{
  "accid": "PF_TRON1A_075", 
  "title": "notify_imu", 
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {
      "euler": [0.0, 0.0, 0.0],     // 欧拉角 [roll, pitch, yaw] in degrees
      "acc": [0.0, 0.0, 0.0],       // 加速度 [x, y, z] in m/s²
      "gyro": [0.0, 0.0, 0.0],      // 陀螺仪角速度 [x, y, z] in rad/s
      "quat": [0.0, 0.0, 0.0, 0.0]  // 四元数 [w, x, y, z]
  }
}
5.5.11 摔倒恢复
5.5.11.1 请求：request_recover
  当机器人摔倒后，可以调用此接口让机器人自动爬起来并恢复到行走模式。
{
  "accid": "PF_TRON1A_075", // 机器人序列号，注意修为您机器人的序列号；
  "title": "request_recover",
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {}
}
5.5.11.2 响应：response_recover
{
  "accid": "PF_TRON1A_075",
  "title": "response_recover",
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {
    "result": "success"  // success: 成功收到指令，开始恢复爬起, fail_no_fallover: 当前没摔倒
  }
}
5.5.11.3 消息推送：notify_recover
完成恢复爬起后，推送此消息。
{
  "accid": "PF_TRON1A_075", 
  "title": "notify_recover", 
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {
      "result": "success"  // success: 摔倒恢复成功, fail_recover: 摔倒恢复失败
  }
}
5.5.12 设置灯效
5.5.12.1 请求：request_light_effect
  该接口用于设置机器人的灯光效果。用户可以通过此接口向机器人发送特定的灯光效果指令，机器人会根据指令调整其灯光显示。
{
  "accid": "PF_TRON1A_075", // 机器人序列号，注意修为您机器人的序列号；
  "title": "request_light_effect",
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {
      "effect": 1
  }
}
  请求参数说明：
参数名
类型
描述
data.effect
数字
灯光效果的编号，对应不同的灯光显示模式，具体映射关系如下：
1: STATIC_RED（静态红色）
2: STATIC_GREEN（静态绿色）
3: STATIC_BLUE（静态蓝色）
4: STATIC_CYAN（静态青色）
5: STATIC_PURPLE（静态紫色）
6: STATIC_YELLOW（静态黄色）
7: STATIC_WHITE（静态白色）
8: LOW_FLASH_RED（低频闪烁红色）
9: LOW_FLASH_GREEN（低频闪烁绿色）
10: LOW_FLASH_BLUE（低频闪烁蓝色）
11: LOW_FLASH_CYAN（低频闪烁青色）
12: LOW_FLASH_PURPLE（低频闪烁紫色）
13: LOW_FLASH_YELLOW（低频闪烁黄色）
14: LOW_FLASH_WHITE（低频闪烁白色）
15: FAST_FLASH_RED（高频闪烁红色）
16: FAST_FLASH_GREEN（高频闪烁绿色）
17: FAST_FLASH_BLUE（高频闪烁蓝色）
18: FAST_FLASH_CYAN（高频闪烁青色）
19: FAST_FLASH_PURPLE（高频闪烁紫色）
20: FAST_FLASH_YELLOW（高频闪烁黄色）
21: FAST_FLASH_WHITE（高频闪烁白色）
5.5.12.2 响应：response_light_effect
{
  "accid": "PF_TRON1A_075",
  "title": "response_light_effect",
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {
    "result": "success"  // success: 成功, fail_light_effect: 失败
  }
}
5.5.12.3 消息推送：无
5.5.13 全局消息
5.5.13.1 机器人基本信息
  机器人基本信息每秒上报一次，包含以下内容：
  - accid：机器人序列号
  - title：notify_robot_info
  - timestamp：消息发出时间戳，单位为毫秒
  - guid：消息的guid值，唯一标识这条消息
  - data：存放消息内容，示例如下：
{
  "accid": "PF_TRON1A_075", 
  "title": "notify_robot_info", 
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": {
    "accid": "PF_TRON1A_075",
    "sw_version": "robot-tron1-2.0.10.20241111103012",
    "imu": "OK",    # 机器人IMU诊断信息
    "camera": "OK", # 机器人相机诊断信息
    "motor": "OK",  # 机器人电机诊断信息
    "battery": 95,  # 机器人电量
    "status": "WALK" # 机器人运行模式
  }
}
字段
说明
accid
机器人序列号
sw_version
机器人本体软件版本信息
imu
机器人IMU诊断信息
camera
机器人相机诊断信息
motor
机器人电机诊断信息
battery
机器人电池电量
status
机器人运行模式：STAND、WALK、SIT、DAMPING、ROTATE、STAIR、ERROR_FALLOVER（摔倒）、RECOVER(摔倒恢复中), ERROR_RECOVER（摔倒恢复失败）
5.5.13.2 非法指令消息
当机器人收到非法格式的请求指令时，发送此消息，包含以下内容：
  - accid：机器人序列号
  - title：notify_invalid_request
  - timestamp：消息发出时间戳，单位为毫秒
  - guid：消息的guid值，唯一标识这条消息
  - data：存放消息内容
  - 示例如下：
{
  "accid": "PF_TRON1A_075", 
  "title": "notify_invalid_request", 
  "timestamp": 1672373633989,
  "guid": "746d937cd8094f6a98c9577aaf213d98",
  "data": "返回原请求指令内容，便于客户端排查问题"
}
5.6 协议接口调用示例
5.6.1 Linux C++ 示例实现
- 安装依赖：以Ubuntu 20.04系统为例，安装websocketpp、nlohmann/json和boost依赖：
sudo apt-get install libboost-all-dev libwebsocketpp-dev nlohmann-json3-dev
- 编译代码
g++ -std=c++11 -o websocket_client websocket_client.cpp -lssl -lcrypto -lboost_system -lpthread
- 运行程序
./websocket_client
- websocket_client.cpp 实现
#include <iostream>
#include <atomic>
#include <string>
#include <thread>
#include <chrono>
#include <websocketpp/client.hpp>
#include <websocketpp/config/asio.hpp> 
#include <nlohmann/json.hpp>
#include <boost/uuid/uuid.hpp>
#include <boost/uuid/uuid_generators.hpp>
#include <boost/uuid/uuid_io.hpp>

using json = nlohmann::json;
using websocketpp::client;
using websocketpp::connection_hdl;

// Replace this ACCID value with your robot's actual serial number (SN)
static std::string ACCID = "";

// WebSocket client instance
static client<websocketpp::config::asio> ws_client;

// Atomic flag for graceful exit
static std::atomic<bool> should_exit(false);

// Connection handle for sending messages
static connection_hdl current_hdl;

// Generate dynamic GUID
static std::string generate_guid() {
    boost::uuids::random_generator gen;
    boost::uuids::uuid u = gen();
    return boost::uuids::to_string(u);
}

// Send WebSocket request with title and data
static void send_request(const std::string& title, const json& data = json::object()) {
    json message;
    
    // Adding necessary fields to the message
    message["accid"] = ACCID;
    message["title"] = title;
    message["timestamp"] = std::chrono::duration_cast<std::chrono::milliseconds>(
                                std::chrono::system_clock::now().time_since_epoch()).count();
    message["guid"] = generate_guid();
    message["data"] = data;

    std::string message_str = message.dump();
    
    // Send the message through WebSocket
    ws_client.send(current_hdl, message_str, websocketpp::frame::opcode::text);
}

// Handle user commands
static void handle_commands() {
    while (!should_exit) {
        std::string command;
        std::cout << "Enter command ('stand', 'walk', 'twist', 'sit', 'stair', 'stop', 'imu') or 'exit' to quit:" << std::endl;
        std::getline(std::cin, command);  // Read user input

        if (command == "exit") {
            should_exit = true;  // Exit flag to stop the loop
            break;
        } else if (command == "stand") {
            send_request("request_stand_mode");  // Send stand mode request
        } else if (command == "walk") {
            send_request("request_walk_mode");  // Send walk mode request
        } else if (command == "twist") {
            float x, y, z;
            std::cout << "Enter x, y, z values:" << std::endl;
            std::cin >> x >> y >> z;  // Get twist values from user
            send_request("request_twist", {{"x", x}, {"y", y}, {"z", z}});
        } else if (command == "sit") {
            send_request("request_sitdown");  // Send sit down request
        } else if (command == "stair") {
            std::string enable;
            std::cout << "Enable stair mode (true/false):" << std::endl;
            std::cin >> enable;  // Get stair mode enable flag from user
            send_request("request_stair_mode", {{"enable", enable == "true" ? true : false}});
        } else if (command == "stop") {
            send_request("request_emgy_stop");  // Send emergency stop request
        } else if (command == "imu") {
            std::string enable;
            std::cout << "Enable IMU (true/false):" << std::endl;
            std::cin >> enable;  // Get IMU enable flag from user
            send_request("request_enable_imu", {{"enable", enable == "true" ? true : false}});
        }
    }
}

// WebSocket open callback
static void on_open(connection_hdl hdl) {
    std::cout << "Connected!" << std::endl;
    
    // Save connection handle for sending messages later
    current_hdl = hdl;

    // Start handling commands in a separate thread
    std::thread(handle_commands).detach();
}

// WebSocket message callback
static void on_message(connection_hdl hdl, client<websocketpp::config::asio>::message_ptr msg) {
    // Parse JSON data from message payload
    json data = json::parse(msg->get_payload());
          
    // Extract 'accid' field if present
    if (data.contains("accid") && data["accid"].is_string() && ACCID.empty()) {
        ACCID = data["accid"].get<std::string>();
    }
    
    std::cout << "Received: " << msg->get_payload() << std::endl;  // Print received message
}

// WebSocket close callback
static void on_close(connection_hdl hdl) {
    std::cout << "Connection closed." << std::endl;
}

// Close WebSocket connection
static void close_connection(connection_hdl hdl) {
    ws_client.close(hdl, websocketpp::close::status::normal, "Normal closure");  // Close connection normally
}

int main() {
    ws_client.init_asio();  // Initialize ASIO for WebSocket client
    
    // Set WebSocket event handlers
    ws_client.set_open_handler(&on_open);  // Set open handler
    ws_client.set_message_handler(&on_message);  // Set message handler
    ws_client.set_close_handler(&on_close);  // Set close handler

    std::string server_uri = "ws://10.192.1.2:5000";  // WebSocket server URI

    websocketpp::lib::error_code ec;
    client<websocketpp::config::asio>::connection_ptr con = ws_client.get_connection(server_uri, ec);  // Get connection pointer

    if (ec) {
        std::cout << "Error: " << ec.message() << std::endl;
        return 1;  // Exit if connection error occurs
    }

    connection_hdl hdl = con->get_handle();  // Get connection handle
    ws_client.connect(con);  // Connect to server
    std::cout << "Press Ctrl+C to exit." << std::endl;
    
    // Run the WebSocket client loop
    ws_client.run();

    return 0;
}
