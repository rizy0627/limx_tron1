4. 底层运动控制开发接口
跨平台底层运动控制开发接口库提供统一的C++/Python API，兼容ROS1、ROS2及非ROS系统，实现运动控制算法的快速移植与部署。通过硬件抽象层和标准化通信协议，开发者可无缝切换仿真与真实硬件环境，显著降低多平台适配成本。
4.1 C++ 运动控制开发接口
4.1.1 getInstance 接口介绍
函数名
getInstance
函数原型
static PointFoot* getInstance();
功能概述
获取 PointFoot 机器人类单例实例的指针
参数
无
返回值
PointFoot*，指向 PointFoot 实例的指针
备注
使用了单例模式，确保 PointFoot 类只有一个实例存在于程序中
代码示例
#include <thread>

// 包含 limxsdk::PointFoot 头文件，用于引入 PointFoot 类
#include "limxsdk/pointfoot.h"  

// 使用 limxsdk 命名空间，简化对 PointFoot 类的引用
using namespace limxsdk;  

int main(int argc, char *argv[]){
  // 获取 PointFoot 类的单例实例
  PointFoot* pf = PointFoot::getInstance(); 
  
  // 无限循环以保持程序运行
  while (true)
  {
    // 休眠 1000 毫秒
    std::this_thread::sleep_for(std::chrono::milliseconds(1000)); 
  }
   
  return 0;
}
4.1.2 init 接口介绍
函数名
init
函数原型
bool init(const std::string& robot_ip_address = "127.0.0.1");
功能概述
初始化运动控制算法程序的通信运行环境，通常在主函数中调用其它接口之前调用，完成初始化工作。
参数
robot_ip_address：机器人的 IP 地址。对于仿真，通常设置为 "127.0.0.1"，而对于真实机器人，可能设置为 "10.192.1.2"。
返回值
如果初始化成功，则返回 true；否则返回 false。
备注
无
代码示例
#include <thread>

// 包含 limxsdk::PointFoot 头文件，用于引入 PointFoot 类
#include "limxsdk/pointfoot.h"  

// 使用 limxsdk 命名空间，简化对 PointFoot 类的引用
using namespace limxsdk;  

int main(int argc, char *argv[]){
  // 获取 PointFoot 类的单例实例
  PointFoot* pf = PointFoot::getInstance();  
  
  // 默认机器人 IP 地址
  std::string robot_ip = "127.0.0.1";
  if (argc > 1)
  {
    // 如果提供了命令行参数，则使用命令行参数作为机器人 IP 地址
    robot_ip = argv[1];
  }
  
  // 初始化运动控制算法程序的通信运行环境
  if (!pf->init(robot_ip))
  {
    // 如果初始化失败，则退出程序
    exit(1); 
  }
  
  // 无限循环以保持程序运行
  while (true)
  {
    // 休眠 1000 毫秒
    std::this_thread::sleep_for(std::chrono::milliseconds(1000)); 
  }
  return 0;
}
4.1.3 getMotorNumber 接口介绍
函数名
getMotorNumber
函数原型
uint32_t getMotorNumber();
功能概述
获取机器人中的电机数量。
参数
无
返回值
返回一个无符号整数，表示机器人中的总电机数量。
备注
通常情况下，点足机器人的电机数量为6个
代码示例
#include <thread>

// 包含 limxsdk::PointFoot 头文件，用于引入 PointFoot 类
#include "limxsdk/pointfoot.h"  

// 使用 limxsdk 命名空间，简化对 PointFoot 类的引用
using namespace limxsdk;  

int main(int argc, char *argv[]){
  // 获取 PointFoot 类的单例实例
  PointFoot* pf = PointFoot::getInstance();  
  
  // 默认机器人 IP 地址
  std::string robot_ip = "127.0.0.1";
  if (argc > 1)
  {
    // 如果提供了命令行参数，则使用命令行参数作为机器人 IP 地址
    robot_ip = argv[1];
  }
  
  // 初始化运动控制算法程序的通信运行环境
  if (!pf->init(robot_ip))
  {
    // 如果初始化失败，则退出程序
    exit(1); 
  }
  
  // 获取机器人中的电机数量
  uint32_t motor_num = pf->getMotorNumber();
  
  // 无限循环以保持程序运行
  while (true)
  {
    // 休眠 1000 毫秒
    std::this_thread::sleep_for(std::chrono::milliseconds(1000)); 
  }
  return 0;
}
4.1.4 subscribeImuData 接口介绍
函数名
subscribeImuData
函数原型
void subscribeImuData(std::function<void(const ImuDataConstPtr&)> cb);
功能概述
订阅机器人的 IMU数据，并在接收到新的 IMU 数据时调用指定的回调函数。
参数
cb: 用于处理新 IMU 数据的回调函数。
返回值
无
备注
ImuData 数据结构原型如下：
/**
 * @struct ImuData
 *
 * @brief 表示基于传感器反馈的机器人 IMU 数据的结构体。
 *
 * 此结构体封装了 IMU 数据，包括加速度计、陀螺仪和四元数。
 */
struct ImuData {
  uint64_t stamp; // 时间戳，以纳秒为单位，通常表示记录或生成此数据时的时间。
  float acc[3];   // 用于存储 IMU 加速度计数据，以跟踪沿三个轴（X、Y、Z）的线性加速度。
  float gyro[3];  // 用于存储 IMU 陀螺仪数据，以跟踪沿三个轴（X、Y、Z）的角速度或旋转速度。
  float quat[4];  // 用于存储 IMU 四元数数据，表示在三维空间中的方向（w、x、y、z）。
};

// 智能指针类型别名
typedef std::shared_ptr<ImuData> ImuDataPtr;
typedef std::shared_ptr<ImuData const> ImuDataConstPtr;
代码示例
#include <thread>

// 包含 limxsdk::PointFoot 头文件，用于引入 PointFoot 类
#include "limxsdk/pointfoot.h"  

// 使用 limxsdk 命名空间，简化对 PointFoot 类的引用
using namespace limxsdk;  

int main(int argc, char *argv[]){
  // 获取 PointFoot 类的单例实例
  PointFoot* pf = PointFoot::getInstance();  
  
  // 默认机器人 IP 地址
  std::string robot_ip = "127.0.0.1";
  if (argc > 1)
  {
    // 如果提供了命令行参数，则使用命令行参数作为机器人 IP 地址
    robot_ip = argv[1];
  }
  
  // 初始化运动控制算法程序的通信运行环境
  if (!pf->init(robot_ip))
  {
    // 如果初始化失败，则退出程序
    exit(1); 
  }
  
  // 订阅机器人状态更新，并指定回调函数
  pf->subscribeImuData([&](const ImuDataConstPtr& msg) {
    // 在这里处理接收到的 ImuData 数据
    // 注意：回调函数会在收到ImuData时被调用
  });
  
  // 无限循环以保持程序运行
  while (true)
  {
    // 休眠 1000 毫秒
    std::this_thread::sleep_for(std::chrono::milliseconds(1000)); 
  }
  return 0;
}
4.1.5 subscribeRobotState 接口介绍
函数名
subscribeRobotState
函数原型
void subscribeRobotState(std::function<void(const RobotStateConstPtr&)> cb);
功能概述
订阅接收关于机器人状态的更新。
参数
cb：回调函数，当接收到机器人状态更新时将被调用。回调函数参数指向 RobotState 对象的常量指针。
返回值
无
备注
- RobotState 数据结构原型如下：
/**
 * @struct RobotState
 *
 * @brief 代表基于传感器反馈的机器人状态的结构体。
 *
 * 此结构封装了各种数据点，可用于监控和控制机器人，包括 IMU 数据（加速度计、陀螺仪、四元数）、输出扭矩、当前角度和速度等。
 */
struct RobotState {
  // 默认构造函数
  RobotState() { } 
  // 带参数的构造函数，用于初始化向量大小为 motor_num 的 tau、q、dq 向量，初始值均为 0.0
  RobotState(int motor_num)
  : tau(motor_num, 0.0)
  , q(motor_num, 0.0)
  , dq(motor_num, 0.0) { }
  uint64_t stamp;              // 时间戳，通常表示记录或生成这些数据的时间，以纳秒为单位
  std::vector<float> tau;      // 用于存储当前估计的输出扭矩（以牛顿米为单位）的向量
  std::vector<float> q;        // 用于存储当前角度（以弧度为单位）的向量
  std::vector<float> dq;       // 用于存储当前速度（以弧度每秒为单位）的向量
};

// 智能指针类型别名
typedef std::shared_ptr<RobotState> RobotStatePtr;
typedef std::shared_ptr<RobotState const> RobotStateConstPtr;
- 机器人状态数据tau、q、dq数组对应的电机顺序如下：
  - 点足
    0: abad_L_Joint, 1: hip_L_Joint, 2: knee_L_Joint
    3: abad_R_Joint, 4: hip_R_Joint, 5: knee_R_Joint
  - 点轮足
    0: abad_L_Joint, 1: hip_L_Joint, 2: knee_L_Joint, 3: wheel_L_Joint
    4: abad_R_Joint, 5: hip_R_Joint, 6: knee_R_Joint, 6: wheel_R_Joint
  - 点双足
    0: abad_L_Joint, 1: hip_L_Joint, 2: knee_L_Joint, 3: ankle_L_Joint
    4: abad_R_Joint, 5: hip_R_Joint, 6: knee_R_Joint, 6: ankle_R_Joint

代码示例
#include <thread>

// 包含 limxsdk::PointFoot 头文件，用于引入 PointFoot 类
#include "limxsdk/pointfoot.h"  

// 使用 limxsdk 命名空间，简化对 PointFoot 类的引用
using namespace limxsdk;  

int main(int argc, char *argv[]){
  // 获取 PointFoot 类的单例实例
  PointFoot* pf = PointFoot::getInstance();  
  
  // 默认机器人 IP 地址
  std::string robot_ip = "127.0.0.1";
  if (argc > 1)
  {
    // 如果提供了命令行参数，则使用命令行参数作为机器人 IP 地址
    robot_ip = argv[1];
  }
  
  // 初始化运动控制算法程序的通信运行环境
  if (!pf->init(robot_ip))
  {
    // 如果初始化失败，则退出程序
    exit(1); 
  }
  
  // 订阅机器人状态更新，并指定回调函数
  pf->subscribeRobotState([&](const RobotStateConstPtr& msg) {
    // 在这里处理接收到的 RobotState 数据
    // 注意：回调函数会在收到机器人状态更新时被调用
  });
  
  // 无限循环以保持程序运行
  while (true)
  {
    // 休眠 1000 毫秒
    std::this_thread::sleep_for(std::chrono::milliseconds(1000)); 
  }
  return 0;
}
4.1.6 publishRobotCmd 接口介绍
函数名
publishRobotCmd
函数原型
bool publishRobotCmd(const RobotCmd& cmd);
功能概述
发布一个命令来 控制机器人的动作。
参数
cmd：表示所需机器人命令的 RobotCmd 对象。
命令数据数组对应的电机顺序如下：
- 点足
  0: abad_L_Joint, 1: hip_L_Joint, 2: knee_L_Joint
  3: abad_R_Joint, 4: hip_R_Joint, 5: knee_R_Joint
- 点轮足
  0: abad_L_Joint, 1: hip_L_Joint, 2: knee_L_Joint, 3: wheel_L_Joint
  4: abad_R_Joint, 5: hip_R_Joint, 6: knee_R_Joint, 6: wheel_R_Joint
- 点双足
  0: abad_L_Joint, 1: hip_L_Joint, 2: knee_L_Joint, 3: ankle_L_Joint
  4: abad_R_Joint, 5: hip_R_Joint, 6: knee_R_Joint, 6: ankle_R_Joint
返回值
无
备注
- RobotCmd 数据结构原型如下：
  /**
   * @struct RobotCmd
   *
   * @brief 代表控制机器人的命令的结构体。
   *
   * 这个结构体包含了可以用于控制机器人的各种命令，包括期望的工作模式、期望的角度、期望的速度、期望的输出扭矩、期望的位置刚度和期望的速度刚度。
   */
  struct RobotCmd {
    RobotCmd() { }
    RobotCmd(int motor_num)
    : mode(motor_num, 0)
    , q(motor_num, 0.0)
    , dq(motor_num, 0.0)
    , tau(motor_num, 0.0)
    , Kp(motor_num, 0.0)
    , Kd(motor_num, 0.0) { }
    uint64_t stamp;             // 时间戳（以纳秒为单位），通常表示记录或生成数据时的时间。
    std::vector<uint8_t> mode;  // 0: 力矩模式控制；1：速度模式控制；2：位置模式控制，默认设置为：0
    std::vector<float> q;       // 存储期望角度的向量（以弧度为单位）。
    std::vector<float> dq;      // 存储期望速度的向量（以弧度每秒为单位）。
    std::vector<float> tau;     // 存储期望输出扭矩的向量（以牛顿米为单位）。
    std::vector<float> Kp;      // 存储期望位置刚度的向量（以牛顿米每弧度为单位）。
    std::vector<float> Kd;      // 存储期望速度刚度的向量（以牛顿米每弧度每秒为单位）。
  };
  
  // 智能指针类型别名     
  typedef std::shared_ptr<RobotCmd> RobotCmdPtr;
  typedef std::shared_ptr<RobotCmd const> RobotCmdConstPtr;  
代码示例
#include <thread>

// 包含 limxsdk::PointFoot 头文件，用于引入 PointFoot 类
#include "limxsdk/pointfoot.h"  

// 使用 limxsdk 命名空间，简化对 PointFoot 类的引用
using namespace limxsdk;  

int main(int argc, char *argv[]){
  // 获取 PointFoot 类的单例实例
  PointFoot* pf = PointFoot::getInstance();  
  
  // 默认机器人 IP 地址
  std::string robot_ip = "127.0.0.1";
  if (argc > 1)
  {
    // 如果提供了命令行参数，则使用命令行参数作为机器人 IP 地址
    robot_ip = argv[1];
  }
  
  // 初始化运动控制算法程序的通信运行环境
  if (!pf->init(robot_ip))
  {
    // 如果初始化失败，则退出程序
    exit(1); 
  }
  
  // 获取机器人中的电机数量
  uint32_t motor_num = pf->getMotorNumber();
  
  // 创建一个包含机器人电机数量的 RobotCmd 对象
  RobotCmd cmd(motor_num);
  
  // 发布控制指令
  pf->publishRobotCmd(cmd);
  
  // 无限循环以保持程序运行
  while (true)
  {
    // 休眠 1000 毫秒
    std::this_thread::sleep_for(std::chrono::milliseconds(1000)); 
  }
  return 0;
}
4.1.7 subscribeSensorJoy 接口介绍
函数名
subscribeSensorJoy
函数原型
void subscribeSensorJoy(std::function<void(const SensorJoyConstPtr&)> cb);
功能概述
在真机部署中，该方法用于订阅来自机器人遥控器的数据。当机器人接收到遥控器的数据时，将会调用指定的回调函数，并传递包含遥控器数据的 SensorJoy 结构体常量指针给回调函数进行处理。
参数
cb: 表示回调函数，用于接收机器人遥控器的数据。回调函数的参数类型为 SensorJoyConstPtr，即指向 SensorJoy 结构体常量的共享指针。
返回值
无
备注

- SensorJoy 数据结构原型如下：
/**
 * @struct SensorJoy
 *
 * @brief 机器人遥控器数据的结构体。
 *
 * 该结构体包含了与遥控器相关的时间戳信息，以及摇杆和按钮值。
 */
struct SensorJoy {
    uint64_t stamp;                     // 与传感器输入相关的时间戳，单位为纳秒。
    std::vector<float> axes;            // 表示操纵摇杆的值。
    std::vector<int32_t> buttons;       // 表示操纵按钮状态的值。
};       

// SensorJoy 智能指针类型的定义
typedef std::shared_ptr<SensorJoy> SensorJoyPtr;
typedef std::shared_ptr<const SensorJoy> SensorJoyConstPtr;
- 遥控器摇杆映射
| 摇杆名          | Axes Index  | 
|----------------|-------------|
| left_horizon   |      0      |
|----------------|-------------|
| left_vertival  |      1      |
|----------------|-------------|
| right_horizon  |      2      |
|----------------|-------------|
| right_vertival |      3      |
|----------------|-------------|

- 遥控器按键映射
|      按键名     | Buttons Index  | 
|----------------|----------------|
|       X        |      0         |
|----------------|----------------|
|       〇       |      1         |
|----------------|----------------|
|       口       |      2         |
|----------------|----------------|
|       △       |      3         |
|----------------|----------------|
|        L1      |      4         |
|----------------|----------------|
|        L2      |      6         |
|----------------|----------------|
|        R1      |      7         |
|----------------|----------------|
|        R2      |      5         |
|----------------|----------------|
|      SELECT    |      8         |
|----------------|----------------|
|       START    |      9         |
|----------------|----------------|
|        UP      |      12        |
|----------------|----------------|
|       DOWN     |      13        |
|----------------|----------------|
|       LEFT     |      14        |
|----------------|----------------|
|       RIGHT    |      15        |
|----------------|----------------|
|       MENU     |      16        |
|----------------|----------------|
|       BACK     |      17        |
|----------------|----------------|
- 适配您自己的按键逻辑时，建议不要和系统预留按键功能冲突了。开发者模式下系统预留按键功能：
| 按键名          | 功能说明      
|----------------|-------------------------------
| L1 + R1        | 机器人校零   
|----------------|-------------------------------
| R1 + Left      | 打开开发者模式     
|----------------|-------------------------------
| R1 + Right     | 打开运动控制模式
|----------------|-------------------------------
| 左 + 右摇杆按键  | 机器人紧急停止   
|----------------|-------------------------------
| 右摇杆按键       | 解除机器人紧急停止   
|----------------|-------------------------------
  
代码示例
#include <thread>

// 包含 limxsdk::PointFoot 头文件，用于引入 PointFoot 类
#include "limxsdk/pointfoot.h"  

// 使用 limxsdk 命名空间，简化对 PointFoot 类的引用
using namespace limxsdk;  

int main(int argc, char *argv[]){
  // 获取 PointFoot 类的单例实例
  PointFoot* pf = PointFoot::getInstance();  
  
  // 默认机器人 IP 地址
  std::string robot_ip = "127.0.0.1";
  if (argc > 1)
  {
    // 如果提供了命令行参数，则使用命令行参数作为机器人 IP 地址
    robot_ip = argv[1];
  }
  
  // 初始化运动控制算法程序的通信运行环境
  if (!pf->init(robot_ip))
  {
    // 如果初始化失败，则退出程序
    exit(1); 
  }
  
  // 订阅机器人遥控器数据
  pf->subscribeSensorJoy([&](const limxsdk::SensorJoyConstPtr &joy) {
    // L1 & R1 按下
    if (joy->buttons[4] == 1 && joy->buttons[7] == 1)
    {
      // 在这里执行相关操作
    }

    // 处理摇杆数据
    double axes_left_horizontal = joy->axes[0];
    double axes_left_vertical = joy->axes[1];
    double axes_right_horizontal = joy->axes[2];
    double axes_right_vertical = joy->axes[3];
  });
  
  // 无限循环以保持程序运行
  while (true)
  {
    // 休眠 1000 毫秒
    std::this_thread::sleep_for(std::chrono::milliseconds(1000)); 
  }
  return 0;
}

4.1.8 subscribeDiagnosticValue 接口介绍
函数名
subscribeDiagnosticValue
函数原型
void subscribeDiagnosticValue(std::function<void(const DiagnosticValueConstPtr&)> cb);
功能概述
在真机部署中，该方法用于订阅机器人的诊断值和状态信息。当机器人发出诊断值时，系统会调用指定的回调函数，并传递包含诊断值的 DiagnosticValue 结构体常量指针给回调函数进行处理。这可以帮助实时监控机器人的健康状态，并及时做出反应以处理可能的问题。
参数
cb: 用于接收机器人诊断值的回调函数，其参数类型为 DiagnosticValueConstPtr，即指向 DiagnosticValue 结构体常量的共享指针。DiagnosticValue 结构体包含了机器人诊断值的信息，包括时间戳、级别、名称、代码和消息字段。
返回值
无
备注
- DiagnosticValue 数据结构原型如下：
/**
 * @struct DiagnosticValue
 *
 * @brief 结构体，表示诊断值。
 *
 * 此结构体包含有关诊断级别、名称、代码和消息的信息。
 */
struct DiagnosticValue {
  enum { OK = 0 };         // 正常状态的诊断级别
  enum { WARN = 1 };       // 警告状态的诊断级别
  enum { ERROR = 2 };      // 错误状态的诊断级别

  uint64_t stamp;          // 时间戳，单位为纳秒。
  int32_t level;           // 与诊断值相关联的级别。
  std::string name;        // 标识诊断值的名称。
  int32_t code;            // 与诊断值对应的代码。
  std::string message;     // 与诊断值相关的详细消息。
};

// DiagnosticValue 智能指针类型的定义
typedef std::shared_ptr<DiagnosticValue> DiagnosticValuePtr;
typedef std::shared_ptr<DiagnosticValue const> DiagnosticValueConstPtr;
- 常见诊断数据
| name        | level  | code | message
|-------------|--------|------|---------------------------------
| version     | OK     |  0   | - 包含软件版本信息
|-------------|--------|------|---------------------------------
| imu         | OK     |  0   | - IMU 工作正常
| imu         | ERROR  | -1   | - IMU 工作异常，包含异常信息
|-------------|--------|------|---------------------------------
| ethercat    | OK     |  0   | - EtherCAT 工作正常
| ethercat    | ERROR  | -1   | - EtherCAT 工作异常，包含异常信息
|-------------|--------|------|---------------------------------
| calibration | OK     |  0   | - 机器人完成校零
| calibration | WARN   |  1   | - 提示：机器人正在校准零中
| calibration | ERROR  | -1   | - 错误：机器人校准零失败，包含失败原因
|-------------|--------|------|----------------------------------
代码示例
#include <thread>

// 包含 limxsdk::PointFoot 头文件，用于引入 PointFoot 类
#include "limxsdk/pointfoot.h"  

// 使用 limxsdk 命名空间，简化对 PointFoot 类的引用
using namespace limxsdk;  

int main(int argc, char *argv[]){
  // 获取 PointFoot 类的单例实例
  PointFoot* pf = PointFoot::getInstance();  
  
  // 默认机器人 IP 地址
  std::string robot_ip = "127.0.0.1";
  if (argc > 1)
  {
    // 如果提供了命令行参数，则使用命令行参数作为机器人 IP 地址
    robot_ip = argv[1];
  }
  
  // 初始化运动控制算法程序的通信运行环境
  if (!pf->init(robot_ip))
  {
    // 如果初始化失败，则退出程序
    exit(1); 
  }
  
  // 订阅机器人诊断数据
  pf->subscribeDiagnosticValue([&](const DiagnosticValueConstPtr& msg) {
    // 在这里处理机器人诊断值
    // 例如，可以根据诊断值的级别和消息来采取相应的措施
    std::cout << "Diagnostic Value: " << msg->name << std::endl;
    std::cout << "Level: " << msg->level << std::endl;
    std::cout << "Code: " << msg->code << std::endl;
    std::cout << "Message: " << msg->message << std::endl;
  });
  
  // 无限循环以保持程序运行
  while (true)
  {
    // 休眠 1000 毫秒
    std::this_thread::sleep_for(std::chrono::milliseconds(1000)); 
  }
  return 0;
}

4.1.9 setRobotLightEffect 接口介绍
函数名
setRobotLightEffect
函数原型
bool setRobotLightEffect(int effect);
功能概述
在真机部署中，该方法用于设置机器人的灯光效果。
参数
effect: 一个整数，表示所需的机器人灯光效果，具体定义见 `PointFoot::LightEffect` 枚举。
返回值
bool: 指示机器人灯光效果是否成功设置。
备注
PointFoot::LightEffect 枚举定义：
enum LightEffect : int {
    STATIC_RED = 0,     // 静态红光
    STATIC_GREEN,       // 静态绿光
    STATIC_BLUE,        // 静态蓝光
    STATIC_CYAN,        // 静态青光
    STATIC_PURPLE,      // 静态紫光
    STATIC_YELLOW,      // 静态黄光
    STATIC_WHITE,       // 静态白光
    LOW_FLASH_RED,      // 红光闪烁（慢闪）
    LOW_FLASH_GREEN,    // 绿光闪烁（慢闪）
    LOW_FLASH_BLUE,     // 蓝光闪烁（慢闪）
    LOW_FLASH_CYAN,     // 青光闪烁（慢闪）
    LOW_FLASH_PURPLE,   // 紫光闪烁（慢闪）
    LOW_FLASH_YELLOW,   // 黄光闪烁（慢闪）
    LOW_FLASH_WHITE,    // 白光闪烁（慢闪）
    FAST_FLASH_RED,     // 红光闪烁（快速闪）
    FAST_FLASH_GREEN,   // 绿光闪烁（快速闪）
    FAST_FLASH_BLUE,    // 蓝光闪烁（快速闪）
    FAST_FLASH_CYAN,    // 青光闪烁（快速闪）
    FAST_FLASH_PURPLE,  // 紫光闪烁（快速闪）
    FAST_FLASH_YELLOW,  // 黄光闪烁（快速闪）
    FAST_FLASH_WHITE    // 白光闪烁（快速闪）
};
代码示例
#include <thread>

// 包含 limxsdk::PointFoot 头文件，用于引入 PointFoot 类
#include "limxsdk/pointfoot.h"  

// 使用 limxsdk 命名空间，简化对 PointFoot 类的引用
using namespace limxsdk;  

int main(int argc, char *argv[]){
  // 获取 PointFoot 类的单例实例
  PointFoot* pf = PointFoot::getInstance();  
  
  // 默认机器人 IP 地址
  std::string robot_ip = "127.0.0.1";
  if (argc > 1)
  {
    // 如果提供了命令行参数，则使用命令行参数作为机器人 IP 地址
    robot_ip = argv[1];
  }
  
  // 初始化运动控制算法程序的通信运行环境
  if (!pf->init(robot_ip))
  {
    // 如果初始化失败，则退出程序
    exit(1); 
  }
  
  // 设置机器人灯光效果为静态红光
  robot->setRobotLightEffect(limxsdk::PointFoot::STATIC_RED);
  
  // 无限循环以保持程序运行
  while (true)
  {
    // 休眠 1000 毫秒
    std::this_thread::sleep_for(std::chrono::milliseconds(1000)); 
  }
  return 0;
}

4.1.10 参考例程
  - 单关节控制例程：
  https://github.com/limxdynamics/limxsdk-lowlevel/blob/master/examples/pf_joint_move.cpp
  - 多关节控制例程：
  https://github.com/limxdynamics/limxsdk-lowlevel/blob/master/examples/pf_groupJoints_move.cpp